import random
from fpdf import FPDF
import smtplib
import sys
import csv
import os
from datetime import datetime, timedelta
import smtplib, ssl
import asyncio
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
from dotenv import load_dotenv 
from reportlab.lib.pagesizes import A4, landscape
from reportlab.lib import colors
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib.units import inch
from datetime import datetime

load_dotenv()

def is_csv_file(filename: str) -> bool:
    """
    Checks if the provided filename is a CSV file.
    Function checks if the given filename ends with the `.csv` extension.
    Parameters:
    filename (str): The name of the file to check.
    Returns: bool: True if the filename ends with `.csv`, False otherwise.
    """
    return filename.lower().endswith('.csv')
    # filestring, ext = filename.lower().split('.')
    # if ext != 'csv':
    #     return False
    # return True

def read_individuals_from_csv(filename):
    """
    Read a list of individuals from a CSV file.
    This function reads a CSV file where each row represents an individual with various attributes.
    The rows are returned as a list of dictionaries, where each dictionary corresponds to a row in the CSV.
    Parameters:
    filename (str): The path to the CSV file to read.
    Returns:
    list: A list of dictionaries, where each dictionary represents an individual and the keys are the CSV column headers.
    Note:
    The CSV file should have headers that correspond to the keys expected in the dictionary, such as 'firstname', 'lastname', and 'email'.
    """
    individuals = []  
    with open(filename, 'r') as file:
        csv_reader = csv.DictReader(file)
        for row in csv_reader:
            individuals.append(row)  
    return individuals

def create_shift_schedule(individuals: list, num_days: int = 30):
    """
    Creates a shift schedule for a list of individuals over a specified number of days.
    This function generates a fair schedule by assigning individuals to three shifts
    ("12 AM - 8 AM", "8 AM - 4 PM", "4 PM - 12 AM") over a period of days. The function
    attempts to distribute shifts as evenly as possible among all individuals.
    Parameters:
    individuals (list): A list of dictionaries, where each dictionary contains the details
                        of an individual (e.g., 'firstname', 'lastname', 'email', etc.).
    num_days (int, optional): The number of days to generate the schedule for. Defaults to 30.
    Returns:
    dict: A dictionary where the keys are dates (in "YYYY-MM-DD" format) and the values are
          dictionaries that map each shift to the assigned individual.
    Raises:
    ValueError: If there are not enough individuals to cover the shifts for a given day.
    """
    shifts = ["12 AM - 8 AM", "8 AM - 4 PM", "4 PM - 12 AM"]
    schedule: dict = {}
    current_date = datetime.today()
    shift_counts = {person['email']: {shift: 0 for shift in shifts} for person in individuals}
    
    for _ in range(num_days):
        date_str = current_date.strftime("%Y-%m-%d")
        schedule[date_str] = {}        
        sorted_individuals = sorted(individuals, key=lambda x: sum(shift_counts[x['email']].values()))
        for shift in shifts:
            if not sorted_individuals:
                raise ValueError(f"Not enough individuals for shifts on {date_str}")            
            sorted_for_shift = sorted(sorted_individuals, key=lambda x: shift_counts[x['email']][shift])            
            assigned_person = sorted_for_shift.pop(0)
            schedule[date_str][shift] = assigned_person            
            shift_counts[assigned_person['email']][shift] += 1
            sorted_individuals.remove(assigned_person)
        current_date += timedelta(days=1)
    
    return schedule

def generate_pdf(schedule: dict, filename: str):
    """
    Generate a PDF document for a shift schedule.
    This function takes a shift schedule (as generated by `create_shift_schedule`) and creates
    a PDF document. The PDF will display a table with the date, shifts, and the corresponding
    assigned individuals for each shift.
    Parameters:
    schedule (dict): The shift schedule dictionary where keys are dates (in "YYYY-MM-DD" format)
                     and values are dictionaries that map each shift to an individual.
    filename (str): The name of the output PDF file.
    Example:
    >>> schedule = {'2024-09-16': {'12 AM - 8 AM': {'firstname': 'John', 'lastname': 'Doe', ...},
                                   '8 AM - 4 PM': {'firstname': 'Jane', 'lastname': 'Doe', ...},
                                   '4 PM - 12 AM': {'firstname': 'John', 'lastname': 'Doe', ...}}}
    >>> generate_pdf(schedule, "shift_schedule.pdf")
    (This will generate a PDF file named "shift_schedule.pdf")
    """
    doc = SimpleDocTemplate(filename, pagesize=landscape(A4))
    elements = []
    styles = getSampleStyleSheet()
    centered_style = styles['Title']
    title = Paragraph("30-Day Shift Schedule", centered_style)
    elements.append(title)
    elements.append(Spacer(1, 0.25 * inch))
    shifts = list(next(iter(schedule.values())).keys())
    table_data = [["Date"] + shifts]
    
    weeks: dict = {}
    for date, day_schedule in schedule.items():
        week_number = datetime.strptime(date, "%Y-%m-%d").isocalendar()[1]
        if week_number not in weeks:
            weeks[week_number] = {}
        weeks[week_number][date] = day_schedule

    for week_number, week_schedule in weeks.items():
        for date, day_schedule in week_schedule.items():
            row = [date]
            for shift in shifts:
                person = day_schedule[shift]
                name = f"{person['firstname']} {person['lastname']}\n{person['phone']}\n{person['email']}"
                row.append(name)
            table_data.append(row)

    table = Table(table_data)

    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.lightblue),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 8),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('GRID', (0, 0), (-1, -1), 0.5, colors.black),
    ]))

    elements.append(table)
    doc.build(elements)

def send_email(recipient_info: dict, subject: str, body: str, attachment: str) -> bool:
    """Send an email with an attached PDF file using details from the .env file.

    Returns:
        bool: True if the email was sent successfully, False otherwise.
    """
    smtp_server = os.getenv('SMTP_SERVER')
    smtp_port = os.getenv('SMTP_PORT')
    sender_email = os.getenv('SENDER_EMAIL')
    sender_password = os.getenv('SENDER_PASSWORD')
    if not all([smtp_server, smtp_port, sender_email, sender_password]):
        raise ValueError("Missing SMTP configuration in the .env file")
    try:
        msg = MIMEMultipart()
        msg['From'] = sender_email
        msg['To'] = recipient_info['email']
        msg['Subject'] = subject
        msg.attach(MIMEText(body, 'plain'))
        if os.path.isfile(attachment):
            with open(attachment, "rb") as file:
                part = MIMEBase('application', 'octet-stream')
                part.set_payload(file.read())
                encoders.encode_base64(part)
                part.add_header('Content-Disposition', f'attachment; filename= {os.path.basename(attachment)}')
                msg.attach(part)
        else:
            raise FileNotFoundError(f"Attachment {attachment} not found.")

        server = smtplib.SMTP(smtp_server, smtp_port)
        server.starttls()
        server.login(sender_email, sender_password)
        server.sendmail(sender_email, recipient_info['email'], msg.as_string())
        server.quit()
        print(f"Email sent successfully to {recipient_info['email']}")
        return True

    except Exception as e:
        print(f"Failed to send email to {recipient_info['email']}. Error: {str(e)}")
        return False



def main():
    if len(sys.argv) == 2:
        csv_file = sys.argv[1]
        if not is_csv_file(csv_file):
            sys.exit("Error: The provided file is not a valid CSV file.")
        individuals = read_individuals_from_csv(csv_file)
        if not individuals:
            sys.exit("Error: No individuals found in the CSV file.")
        schedule = create_shift_schedule(individuals)     
        generate_pdf(schedule, "shift_schedule.pdf")
        for individual in individuals:
            send_email(individual, "Your Shift Schedule", "Please find your shift schedule attached.", "shift_schedule.pdf")
    elif len(sys.argv) > 2:
        sys.exit('Too many command-line arguments')
    else:
        sys.exit('Too few command-line arguments')
    
if __name__ == "__main__":
    main()